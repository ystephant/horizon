<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Horizon PRO V2</title>

<style>
body{
  margin:0;
  overflow:hidden;
  background:#000;
  font-family:system-ui;
  color:#fff;
}

#ar{
  position:fixed;
  inset:0;
  background:linear-gradient(#02122a,#000);
}

#poic{
  position:absolute;
  inset:0;
  pointer-events:none;
  overflow:hidden;
}

.poi{
  position:absolute;
  will-change:transform;
  transform:translate3d(-50%,0,0);
  transition:opacity .2s ease;
  pointer-events:none;
}

.pob{
  background:rgba(0,0,0,.65);
  padding:6px 12px;
  border-radius:16px;
  backdrop-filter:blur(6px);
  font-size:13px;
  white-space:nowrap;
  text-align:center;
}

.poc{
  width:2px;
  height:40px;
  margin:auto;
  background:#00e5ff;
}

#cfocus{
  position:absolute;
  bottom:24px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(0,0,0,.85);
  padding:14px 22px;
  border-radius:24px;
  text-align:center;
  display:none;
  backdrop-filter:blur(8px);
}

#cfocus.on{display:block}

#cfocus strong{
  font-size:16px;
  display:block;
}
</style>
</head>

<body>

<div id="ar">
  <div id="poic"></div>
</div>

<div id="cfocus">
  <strong id="cfn"></strong>
  <div id="cfd"></div>
  <div id="cft"></div>
</div>

<script>
/* ======================================================
   CONFIGURATION GLOBALE
====================================================== */

const CONFIG = {
  FOV: 70,
  MAX_VISIBLE: 35,
  OVERPASS_RADIUS: 30000,
  OVERPASS_REFRESH_DISTANCE: 1000,
  ALT_BATCH_SIZE: 50,
  ALT_API: "https://api.open-elevation.com/api/v1/lookup",
  FOCUS_HARD: 2,
  FOCUS_SOFT: 5,
  ALIGNMENT_WEIGHT: 2.5,
  DISTANCE_WEIGHT: 1.8,
  ALTITUDE_WEIGHT: 1.2
};

CONFIG.FOV2 = CONFIG.FOV / 2;

/* ======================================================
   STATE CENTRAL
====================================================== */

const STATE = {
  lat:null,
  lng:null,
  alt:0,
  pitch:0,
  headingRaw:null,
  headingSmooth:null,
  gpsReady:false,
  pois:[],
  visible:[],
  altitudeCache:new Map(),
  lastFetchLat:null,
  lastFetchLng:null,
  lastHeading:null
};

const POI_POOL = [];
const POI_ACTIVE = new Map();

/* ======================================================
   UTILITAIRES MATH
====================================================== */

const rad = x => x*Math.PI/180;
const deg = x => x*180/Math.PI;

function haversine(a,b,c,d){
  const R=6371000;
  const dLat=rad(c-a);
  const dLon=rad(d-b);
  const q=Math.sin(dLat/2)**2+
  Math.cos(rad(a))*Math.cos(rad(c))*
  Math.sin(dLon/2)**2;
  return 2*R*Math.atan2(Math.sqrt(q),Math.sqrt(1-q));
}

function bearing(a,b,c,d){
  const y=Math.sin(rad(d-b))*Math.cos(rad(c));
  const x=Math.cos(rad(a))*Math.sin(rad(c))-
  Math.sin(rad(a))*Math.cos(rad(c))*Math.cos(rad(d-b));
  return (deg(Math.atan2(y,x))+360)%360;
}

function normalize(d){
  return ((d+540)%360)-180;
}

/* ======================================================
   GPS TRACKING + REFRESH INTELLIGENT
====================================================== */

navigator.geolocation.watchPosition(pos=>{
  const newLat = pos.coords.latitude;
  const newLng = pos.coords.longitude;
  const newAlt = pos.coords.altitude || 0;

  if(STATE.lat && STATE.lng){
    const moved = haversine(STATE.lat,STATE.lng,newLat,newLng);
    if(moved > CONFIG.OVERPASS_REFRESH_DISTANCE){
      fetchPOIs(newLat,newLng);
    }
  }else{
    fetchPOIs(newLat,newLng);
  }

  STATE.lat = newLat;
  STATE.lng = newLng;
  STATE.alt = newAlt;
  STATE.gpsReady = true;

},{enableHighAccuracy:true});

/* ======================================================
   COMPASS + SMOOTHING
====================================================== */

window.addEventListener("deviceorientation",e=>{

  let heading = null;

  if(e.webkitCompassHeading != null){
    heading = e.webkitCompassHeading;
  }else if(e.alpha != null){
    heading = (360 - e.alpha) % 360;
  }

  if(heading != null){
    if(STATE.headingSmooth == null){
      STATE.headingSmooth = heading;
    }else{
      let delta = heading - STATE.headingSmooth;
      if(delta > 180) delta -= 360;
      if(delta < -180) delta += 360;
      STATE.headingSmooth = (STATE.headingSmooth + delta * 0.15 + 360) % 360;
    }
    STATE.headingRaw = heading;
  }

  STATE.pitch = e.beta || 0;

});

/* ======================================================
   OVERPASS PRO MULTI-CATEGORIES
====================================================== */

async function fetchPOIs(lat,lng){

  if(!lat || !lng) return;

  STATE.lastFetchLat = lat;
  STATE.lastFetchLng = lng;

  const query = `
  [out:json][timeout:25];
  (
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["place"];
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["natural"="peak"];
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["natural"="volcano"];
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["natural"="wood"];
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["natural"="beach"];
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["man_made"="lighthouse"];
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["tourism"="attraction"];
    node(around:${CONFIG.OVERPASS_RADIUS},${lat},${lng})["historic"];
  );
  out body;
  `;

  const res = await fetch("https://overpass-api.de/api/interpreter",{
    method:"POST",
    body:query
  }).then(r=>r.json()).catch(()=>null);

  if(!res || !res.elements) return;

  const unique = new Map();

  for(const e of res.elements){

    if(!e.tags || !e.tags.name) continue;

    const dist = haversine(lat,lng,e.lat,e.lon);
    if(dist < 50) continue;

    const key = e.tags.name.toLowerCase();

    if(unique.has(key)){
      if(dist < unique.get(key).dist){
        unique.set(key,{e,dist});
      }
    }else{
      unique.set(key,{e,dist});
    }
  }

  const list = [];

  unique.forEach(obj=>{
    const e = obj.e;
    const dist = obj.dist;

    list.push({
      id: e.id,
      name: e.tags.name,
      lat: e.lat,
      lng: e.lon,
      dist: dist,
      bearing: bearing(lat,lng,e.lat,e.lon),
      alt: e.tags.ele ? parseFloat(e.tags.ele) : null
    });
  });

  STATE.pois = list;

  fetchAltitudeBatch();

}

/* ======================================================
   ALTITUDE BATCH + CACHE
====================================================== */

async function fetchAltitudeBatch(){

  const batch = [];

  for(const p of STATE.pois){

    const key = p.lat+","+p.lng;

    if(STATE.altitudeCache.has(key)){
      p.alt = STATE.altitudeCache.get(key);
    }else{
      batch.push(p);
    }

    if(batch.length >= CONFIG.ALT_BATCH_SIZE) break;
  }

  if(!batch.length) return;

  const coords = batch.map(p=>`${p.lat},${p.lng}`).join("|");

  const data = await fetch(`${CONFIG.ALT_API}?locations=${coords}`)
  .then(r=>r.json())
  .catch(()=>null);

  if(!data || !data.results) return;

  data.results.forEach((r,i)=>{
    const p = batch[i];
    if(!p) return;
    p.alt = r.elevation;
    STATE.altitudeCache.set(p.lat+","+p.lng,r.elevation);
  });

}

/* ======================================================
   OBJECT POOLING DOM
====================================================== */

function createPOIElement(){
  const el = document.createElement("div");
  el.className = "poi";
  el.innerHTML = `
    <div class="poc"></div>
    <div class="pob">
      <div class="name"></div>
      <div class="dist"></div>
    </div>
  `;
  document.getElementById("poic").appendChild(el);
  return el;
}

function getPOIElement(id){
  if(POI_ACTIVE.has(id)){
    return POI_ACTIVE.get(id);
  }
  let el = POI_POOL.pop();
  if(!el) el = createPOIElement();
  POI_ACTIVE.set(id,el);
  return el;
}

function releaseUnused(activeIds){
  for(const [id,el] of POI_ACTIVE.entries()){
    if(!activeIds.has(id)){
      el.style.opacity = 0;
      POI_ACTIVE.delete(id);
      POI_POOL.push(el);
    }
  }
}

/* ======================================================
   SCORING INTELLIGENT
====================================================== */

function computeScore(p,df,verticalAngle){

  const distScore = 1 / (p.dist + 1);
  const alignScore = 1 / (Math.abs(df) + 1);
  const altScore = 1 / (Math.abs(verticalAngle) + 1);

  let focusBonus = 0;
  if(Math.abs(df) < CONFIG.FOCUS_HARD) focusBonus = 2;
  else if(Math.abs(df) < CONFIG.FOCUS_SOFT) focusBonus = 1;

  return (
    distScore * CONFIG.DISTANCE_WEIGHT +
    alignScore * CONFIG.ALIGNMENT_WEIGHT +
    altScore * CONFIG.ALTITUDE_WEIGHT +
    focusBonus
  );
}

/* ======================================================
   RENDER ENGINE GPU
====================================================== */

function render(){

  requestAnimationFrame(render);

  if(!STATE.gpsReady || STATE.headingSmooth == null) return;

  if(STATE.lastHeading &&
     Math.abs(normalize(STATE.headingSmooth - STATE.lastHeading)) < 0.1){
    return;
  }

  STATE.lastHeading = STATE.headingSmooth;

  const W = window.innerWidth;
  const H = window.innerHeight;

  const visible = [];
  const activeIds = new Set();

  for(const p of STATE.pois){

    const df = normalize(p.bearing - STATE.headingSmooth);
    if(Math.abs(df) > CONFIG.FOV2) continue;

    const altitude = p.alt ?? 0;
    const verticalAngle = deg(Math.atan2(altitude - STATE.alt,p.dist));

    const screenY = H/2 - (verticalAngle - STATE.pitch) * 8;

    const score = computeScore(p,df,verticalAngle);

    visible.push({...p,df,screenY,score});
  }

  visible.sort((a,b)=>b.score - a.score);

  STATE.visible = visible.slice(0,CONFIG.MAX_VISIBLE);

  let best = null;

  for(const p of STATE.visible){

    const el = getPOIElement(p.id);
    activeIds.add(p.id);

    const x = W/2 + (p.df / CONFIG.FOV2) * (W/2);

    el.style.transform = `translate3d(${x}px,${p.screenY}px,0)`;
    el.style.opacity = 1;

    el.querySelector(".name").textContent = p.name;
    el.querySelector(".dist").textContent =
      p.dist < 1000
      ? Math.round(p.dist)+" m"
      : (p.dist/1000).toFixed(1)+" km";

    if(Math.abs(p.df) < CONFIG.FOCUS_HARD){
      best = p;
    }
  }

  releaseUnused(activeIds);

  updateFocus(best);
}

/* ======================================================
   FOCUS EXACT EN FACE
====================================================== */

function updateFocus(p){

  const badge = document.getElementById("cfocus");

  if(!p){
    badge.classList.remove("on");
    return;
  }

  badge.classList.add("on");
  document.getElementById("cfn").textContent = p.name;
  document.getElementById("cfd").textContent =
    p.dist < 1000
    ? Math.round(p.dist)+" m"
    : (p.dist/1000).toFixed(1)+" km";

  document.getElementById("cft").textContent =
    Math.abs(p.df) < CONFIG.FOCUS_HARD
    ? "ðŸŽ¯ Alignement parfait"
    : "En face";
}

/* ======================================================
   START ENGINE
====================================================== */

render();

</script>
</body>
</html>
